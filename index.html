<!doctype html>
<html>
  <head>
    <link rel=stylesheet type=text/css href=build/app.css />
    <link rel=stylesheet type=text/css href=build/jspm_packages/github/components/highlightjs@8.5.0/styles/sunburst.css />

    <script src=build/jspm_packages/system.js></script>
    <script src=config.js></script>
    <script>System.import('init')</script>
  </head>
  <body class=loading>
    <aside>
      <ul></ul>
    </aside>

    <section class="intro">
      <header data-markdown>
        ![vb](img/vb.gif)

        ![lights](img/lights.gif)

        LNUG talk ![microphone](img/microphone.gif) May 27th 1998 - Mr Friend
      </header>
      <div data-markdown>
        # Build systems for the web and node.js

        Current javascript state of the art compared to sigh, a functional reactive declarative build automation system.
      </div>
      <footer data-markdown>
        ![waving](img/uk-waving.gif)
        ![geocities](img/geocities.gif)
        <table border=6><tr><td>
          [email coolguy82@hotmail.com](http://chilon.net)
        </td></tr></table>
      </footer>
    </section>

    <section class="history">
      <div data-markdown>
        # History

        * node 0.0.1 released in May 2009.
        * CoffeeScript 0.1 in December 2009.
        * npm 0.0.1 in January 2010 (node at 0.1).
        * CoffeeScript 1.0 in December 2010
        * npm 1.0.1 released in April 2011 (node at 0.4)
        * grunt first released in January 2012.
      </div>
    </section>

    <section class="before-grunt">
      <div data-markdown>
        # Before grunt

        * Gnu make: Makefile (gruntfile.js, gulpfile.js etc.)
        * action: kitten pops up holding makefile... -j3 etc.
        * Shell scripts
        * Custom build scripts written in javascript
        * Other stuff
      </div>
    </section>

    <section class="oh-grunt">
      <div data-markdown>
        # Is grunt a build system? Nope

        * Task runner, asset pipeline stuff has to be custom written.
        * Tasks build code by compiling it in a temporary directory.
        * yeoman angular fullstack generator "best practice" gruntfile, 667 lines long:
        * No release for 11 months.
      </div>
      <link rel=import href=gruntfile.js.html />
    </section>

    <section class="gulp">
      <div data-markdown>
        # Gulp

        * gulp was released 1.5yrs after grunt in July 2013
        * pipelines are node streams
        * plugins are (mostly) stream transforms, 1 source file in 1 destination file out.
        * The streams are exposed directly to build files.
      </div>
    </section>

    <section class="oh-gulp">
      <div data-markdown>
        * Streams transforms are built around transforming files 1:1
          * n:n/1:n/n:1 transforms more difficult.
        * Concatenating source maps doesn't always work.
        * Node stream API not so good for this task:
          * gulp-plumber
        * Example from [here](https://github.com/gulpjs/gulp/) PIPE PIPE PIPE POPEYE
        * PIPE
      </div>
    </section>

    <section class="oh-gulp-2">
      <header>
        <img data-marquee="-50px:200px:2000" alt="jo liss on gulp" src=img/ibelieve.jpg />
      </header>
      <div>
        <img data-marquee data-blink alt=facepalm src=img/facepalm.jpg />
      </div>
      <footer data-markdown>
        * Need to use 4 plugins together for incremental rebuilds.
          * gulp-changed (or gulp-newer): only pass through changed files.
          * gulp-cached: in memory file cache.
          * gulp-remember: keep unchanged files cached.
          * gulp-order: To maintain file order.
      </footer>
    </section>


    <section class="broccoli">
      <div data-markdown>
        # Broccoli

        * First release May 2013
        * Currently in beta
        * Plugins take one or more trees (filesystem directories).
        * Output one or more trees (containing built assets).
        * "The filesystem is the API"
      </div>
    </section>

    <section class="oh-broccoli">
      <div data-markdown>
        # But...

        * Source maps only sometimes working.
          * Most plugins lack transitive application.
          * Broccoli currently provides no helpers for this.
        * Use of filesystem means plugins must clean-up.
        * Everything sequential, can't parallelise: "only a 40% speed gain".
        * Brocfile.js files can get verbose.
      </div>
    </section>

    <section class="the-rest">
      <div data-markdown>
        # Other pipelines

        * metalsmith
        * plumber (no changes in 6+ months).
        * gobble
      </div>
    </section>

    <section class="moaning">
      <div data-markdown>
        # Problems with Everything

        * I make a change while the tests are running and:
          * Let me ignore that for you. (TODO: troll bullet point)
          * Let me get to that when your tests finish running.
        * Production source maps.
        * Need special handling for watching files.
      </div>
    </section>

    <section class="sigh-1">
      <div data-markdown>
        # sigh

        * Functional Reactive Programming (sloth hugging kitten)
        * Like lodash of streams (flatten, reduce etc.)
        * n:n operations: in sigh each event is an array of files rather than a single file.
        * Does not use fs except when absolutely necessary.
        * Provides lovely APIs for plugin writers
          * Spreading work over multiple processes/CPUs.
          * Working with source maps (application, concatenation).
        * Source maps from minified/transpiled files back to original sources.
        * Very neat Assetfile.js syntax.
          * Only plugin authors have to interact with stream API.
          * Abstract from sigh.js, array and plugin based tree structure.
      </div>
    </section>

    <section class="sigh-2">
      <div data-markdown>
        # Uses multiple CPUs/cores

        * Show sigh being faster than compiling files directly with babel.
      </div>
    </section>

    <section class="sigh-3">
      <div data-markdown>
        # Kills running tests

        * Show how they restart
        * But how does the replacement process start so quickly?
        * Two processes are waiting!

        # Structure

        * Make bigger pipelines by connecting pipelines together.
      </div>
    </section>
  </body>
</html>
